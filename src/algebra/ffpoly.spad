)abbrev package FFPOLY FiniteFieldPolynomialPackage
++ Author: A. Bouyer, J. Grabmeier, A. Scheerhorn, R. Sutor, B. Trager
++ Date Created: January 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, polynomial, irreducible polynomial, normal
++   polynomial, primitive polynomial, random polynomials
++ References:
++   [LS] Lenstra, H. W. & Schoof, R. J., "Primitivive Normal Bases
++        for Finite Fields", Math. Comp. 48, 1987, pp. 217-231
++   [LN] Lidl, R. & Niederreiter, H., "Finite Fields",
++        Encycl. of Math. 20, Addison-Wesley, 1983
++  J. Grabmeier, A. Scheerhorn: Finite Fields in Axiom.
++   Axiom Technical Report Series, ATR/5 NP2522.
++ Description:
++   This package provides a number of functions for generating, counting
++   and testing irreducible, normal, primitive, random polynomials
++   over finite fields.

FiniteFieldPolynomialPackage(GF): Exports == Implementation where

  GF : FiniteFieldCategory

  I    ==> Integer
  L    ==> List
  NNI  ==> NonNegativeInteger
  PI   ==> PositiveInteger
  Rec  ==> Record(expnt : NNI, coeff : GF)
  Repr ==> L Rec
  SUP  ==> SparseUnivariatePolynomial GF

  Exports ==> with
 --    qEulerPhiCyclotomic : PI -> PI
--      ++ qEulerPhiCyclotomic(n)$FFPOLY(GF) yields the q-Euler's function
--      ++ of the n-th cyclotomic polynomial over the field {\em GF} of
--      ++ order q (cf. [LN] p.122);
--      ++ error if n is a multiple of the field characteristic.
    primitive? : SUP -> Boolean
      ++ primitive?(f) tests whether the polynomial f over a finite
      ++ field is primitive, i.e. all its roots are primitive.
    normal? : SUP -> Boolean
      ++ normal?(f) tests whether the polynomial f over a finite field is
      ++ normal, i.e. its roots are linearly independent over the field.
    numberOfIrreduciblePoly : PI -> PI
      ++ numberOfIrreduciblePoly(n)$FFPOLY(GF) yields the number of
      ++ monic irreducible univariate polynomials of degree n
      ++ over the finite field {\em GF}.
    numberOfPrimitivePoly : PI -> PI
      ++ numberOfPrimitivePoly(n)$FFPOLY(GF) yields the number of
      ++ primitive polynomials of degree n over the finite field {\em GF}.
    numberOfNormalPoly : PI -> PI
      ++ numberOfNormalPoly(n)$FFPOLY(GF) yields the number of
      ++ normal polynomials of degree n over the finite field {\em GF}.
    createIrreduciblePoly : PI -> SUP
      ++ createIrreduciblePoly(n)$FFPOLY(GF) generates a monic irreducible
      ++ univariate polynomial of degree n over the finite field {\em GF}.
    createPrimitivePoly : PI -> SUP
      ++ createPrimitivePoly(n)$FFPOLY(GF) generates a primitive polynomial
      ++ of degree n over the finite field {\em GF}.
    createNormalPoly : PI -> SUP
      ++ createNormalPoly(n)$FFPOLY(GF) generates a normal polynomial
      ++ of degree n over the finite field {\em GF}.
    createNormalPrimitivePoly : PI -> SUP
      ++ createNormalPrimitivePoly(n)$FFPOLY(GF) generates a normal and
      ++ primitive polynomial of degree n over the field {\em GF}.
      ++ Note: this function is equivalent to createPrimitiveNormalPoly(n)
    createPrimitiveNormalPoly : PI -> SUP
      ++ createPrimitiveNormalPoly(n)$FFPOLY(GF) generates a normal and
      ++ primitive polynomial of degree n over the field {\em GF}.
    lexSmaller? : (SUP, SUP) -> Boolean
      ++ lexSmaller?(f, g) compares monic f and g of the same
      ++ degree in the following order.
      ++ Error: if f or g is not monic or if f and g have different
      ++ degrees or if common degree is 0.
      ++ \spad{f < g} if
      ++ the number of monomials of f is less
      ++ than this number for g.
      ++ If f and g have the same number of monomials,
      ++ the lists of exponents are compared lexicographically.
      ++ If these lists are also equal, the lists of coefficients
      ++ are compared according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
    clexSmaller? : (SUP, SUP) -> Boolean
      ++ clexSmaller?(f, g) compares monic f and g of the same
      ++ degree in the following order.
      ++ Error: if f or g is not monic or if f and g have different
      ++ degrees or if common degree is 0.
      ++ \spad{f < g} if the constant term of \spad{f} is zero
      ++ and constant term of \spad{g} is nonzero.
      ++ If both
      ++ constant term of \spad{f} and \spad{g} are nonzero
      ++ then \spad{f < g} if the {\em lookup} of the constant term
      ++ of f is less than
      ++ this number for g.
      ++ If these values are equal, then \spad{lexSmaller?} is used
      ++ as ordering predicate.
    nlexSmaller? : (SUP, SUP) -> Boolean
      ++ nlexSmaller?(f, g) compares monic f and g of the same
      ++ degree \pdad{n} in the following order.
      ++ Error: if f or g is not monic or if f and g have different
      ++ degrees or if common degree is 0.
      ++ \spad{f < g} if the coefficient of the term of degree {\em n-1}
      ++ of \spad{f} is zero and than that for g is nonzero.
      ++ Also, \spad{f < g} if both coefficients are nonzero and
      ++ {\em lookup} of the coefficient of \spad{f} is less than
      ++ that for \spad{g}.
      ++ In case those coefficients are equal, then \spad{lexSmaller?}
      ++ is used as ordering predicate.
    cnlexSmaller? : (SUP, SUP) -> Boolean
      ++ cnlexSmaller?(f, g) compares monic f and g of the same
      ++ degree \pdad{n} in the following order.
      ++ Error: if f or g is not monic or if f and g have different
      ++ degrees or if common degree is 0.
      ++ \spad{f < g} if the constant term of \spad{f} is zero
      ++ and constant term of \spad{g} is nonzero.  If both
      ++ constant term of \spad{f} and \spad{g} are nonzero
      ++ then \spad{f < g} if the {\em lookup} of the constant term
      ++ of f is less than
      ++ this number for g.
      ++ If constant terms are equal then \spad{nlexSmaller?}
      ++ is used as ordering predicate.
    nextIrreduciblePoly : SUP -> Union(SUP, "failed")
      ++ nextIrreduciblePoly(f) yields the next monic irreducible polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ \spad{lexSmaller?} is used as ordering predicate.
    nextPrimitivePoly : SUP -> Union(SUP, "failed")
      ++ nextPrimitivePoly(f) yields the next primitive polynomial over
      ++ a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ \spad{clexSmaller?} is used as ordering predicate.
    nextNormalPoly : SUP -> Union(SUP, "failed")
      ++ nextNormalPoly(f) yields the next normal polynomial over
      ++ a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ \spad{nlexSmaller?} is used as ordering predicate.
    nextNormalPrimitivePoly : SUP -> Union(SUP, "failed")
      ++ nextNormalPrimitivePoly(f) yields the next normal primitive polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ \spad{cnlexSmaller?} is used as ordering predicate.
      ++ This operation is equivalent to nextPrimitiveNormalPoly(f).
    nextPrimitiveNormalPoly : SUP -> Union(SUP, "failed")
      ++ nextPrimitiveNormalPoly(f) yields the next primitive normal polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ \spad{cnlexSmaller?} is used as ordering predicate.
      ++ This operation is equivalent to nextNormalPrimitivePoly(f).
--    random : () -> SUP
--      ++ random()$FFPOLY(GF) generates a random monic polynomial
--      ++ of random degree over the field {\em GF}
    random : PI -> SUP
      ++ random(n)$FFPOLY(GF) generates a random monic polynomial
      ++ of degree n over the finite field {\em GF}.
    random : (PI, PI) -> SUP
      ++ random(m, n)$FFPOLY(GF) generates a random monic polynomial
      ++ of degree d over the finite field {\em GF}, d between m and n.
    leastAffineMultiple : SUP  -> SUP
      ++ leastAffineMultiple(f) computes the least affine polynomial which
      ++ is divisible by the polynomial f over the finite field {\em GF},
      ++ i.e. a polynomial whose exponents are 0 or a power of q, the
      ++ size of {\em GF}.
    reducedQPowers : SUP  -> PrimitiveArray SUP
      ++ reducedQPowers(f)
      ++ generates \spad{[x, x^q, x^(q^2), ..., x^(q^(n-1))]}
      ++ reduced modulo f where \spad{q = size()$GF} and \spad{n = degree f}.
    --
    -- we intend to implement also the functions
    -- cyclotomicPoly: PI -> SUP, order: SUP -> PI,
    -- and maybe a new version of irreducible?


  Implementation ==> add

    import from IntegerNumberTheoryFunctions
    import from DistinctDegreeFactorize(GF, SUP)

    sizeGF : PI := size()$GF :: PI

    char_GF : PI := characteristic()$GF :: PI

    deg_GF : NNI := 0

    get_deg_GF() : PI ==
        if deg_GF = 0 then
            n : PI := 1$PI;
            ss : NNI := sizeGF;
            while ss > char_GF repeat
                ss := (ss exquo$NNI char_GF)::NNI
                n := n +$PI 1$PI
            deg_GF := n
        deg_GF::PI

    elem1 : GF := index(1)$GF

    poly_or_prime_rep := representationType()$GF case "polynomial"
                         or representationType()$GF case "prime"

    MM := ModMonic(GF, SUP)

    rep_to_SUP(l) ==> l pretend SUP

    listToSUP(l : Repr) : SUP ==
        newl : Repr := [copy t for t in l]
        rep_to_SUP(newl)

    nextSubset : (L NNI, NNI) -> Union(L NNI, "failed")
      -- for a list s of length m with 1 <= s.1 < ... < s.m <= bound,
      -- nextSubset(s, bound) yields the immediate successor of s
      -- (resp. "failed" if s = [1,...,bound])
      -- where s < t if and only if:
      -- (i)  #s < #t; or
      -- (ii) #s = #t and s < t in the lexicographical order;
      -- (we have chosen to fix the signature with NNI instead of PI
      --  to avoid coercions in the main functions)

    reducedQPowers(f) ==
      m : PI := qcoerce(degree(f)$SUP)
      m1 : I := m-1
      setPoly(f)$MM
      e := reduce(monomial(1, 1)$SUP)$MM ^ sizeGF
      w := 1$MM
      qpow : PrimitiveArray SUP := new(m, 0)
      qpow.0 := 1$SUP
      for i in 1..m1 repeat  qpow.i := lift(w := w*e)$MM
      qexp : PrimitiveArray SUP := new(m, 0)
      m = 1 =>
        qexp.(0$I) := (-coefficient(f, 0$NNI)$SUP)::SUP
        qexp
      qexp.0$I := monomial(1, 1)$SUP
      h := qpow.1
      qexp.1 := h
      for i in 2..m1 repeat
        g := 0$SUP
        while h ~= 0 repeat
          g := g + leadingCoefficient(h) * qpow.degree(h)
          h := reductum(h)
        qexp.i := (h := g)
      qexp

    leastAffineMultiple(f) ==
    -- [LS] p.112
      qexp := reducedQPowers(f)
      n := degree(f)$SUP
      b : Matrix GF := transpose matrix [entries vectorise
           (qexp.i, n) for i in 0..n-1]
      col1 : Matrix GF := new(n, 1, 0)
      col1(1, 1)  := 1
      ns : List Vector GF := nullSpace (horizConcat(col1, b) )
      ----------------------------------------------------------------
      -- perhaps one should use that the first vector in ns is already
      -- the right one
      ----------------------------------------------------------------
      dim := n+2
      coeffVector : Vector GF
      until empty? ns repeat
        newCoeffVector := ns.1
        i : PI := qcoerce(n + 1)
        while newCoeffVector(i) = 0 repeat
          i := qcoerce(i - 1)
        if i < dim then
          dim := i
          coeffVector := newCoeffVector
        ns := rest ns
      (coeffVector(1)::SUP) +(+/[monomial(coeffVector.k, _
               sizeGF^((k-2)::NNI))$SUP for k in 2..dim])

--    qEulerPhiCyclotomic n ==
--      n = 1 => qcoerce(sizeGF - 1)
--      p : PI := characteristic()$GF :: PI
--      (n rem p) = 0 => error
--        "cyclotomic polynomial not defined for this argument value"
--      q  : PI := sizeGF
--      -- determine the multiplicative order of q modulo n
--      e  : PI := 1
--      qe : PI := q
--      while (qe rem n) ~= 1 repeat
--        e  := e + 1
--        qe := qe * q
--      qcoerce((qe - 1) ^ (qcoerce(eulerPhi(n) quo e)) )

    numberOfIrreduciblePoly n ==
      -- we compute the number Nq(n) of monic irreducible polynomials
      -- of degree n over the field GF of order q by the formula
      -- Nq(n) = (1/n)* sum(moebiusMu(n/d)*q^d) where the sum extends
      -- over all divisors d of n (cf. [LN] p.93, Th. 3.25)
      n = 1 => sizeGF
      -- the contribution of d = 1 :
      lastd : PI  := 1
      qd    : PI  := sizeGF
      sum   :  I  := moebiusMu(n) * qd
      -- the divisors d > 1 of n :
      divisorsOfn : L PI := rest(divisors n) pretend L PI
      for d in divisorsOfn repeat
        qd := qd * (sizeGF) ^ (qcoerce(d - lastd))
        sum := sum + moebiusMu(n quo d) * qd
        lastd := d
      (sum quo n) :: PI

    numberOfPrimitivePoly n == (eulerPhi((sizeGF ^ n) - 1) quo n) :: PI
      -- [each root of a primitive polynomial of degree n over a field
      --  with q elements is a generator of the multiplicative group
      --  of a field of order q^n (definition), and the number of such
      --  generators is precisely eulerPhi(q^n - 1)]

    numberOfNormalPoly n ==
      -- we compute the number Nq(n) of normal polynomials of degree n
      -- in GF[X], with GF of order q, by the formula
      -- Nq(n) = (1/n) * qPhi(X^n - 1) (cf. [LN] p.124) where,
      -- for any polynomial f in GF[X] of positive degree n,
      -- qPhi(f) = q^n * (1 - q^(-n1)) *...* (1 - q^(-nr)) =
      -- q^n * ((q^(n1)-1) / q^(n1)) *...* ((q^(nr)-1) / q^(n_r)),
      -- the ni being the degrees of the distinct irreducible factors
      -- of f in its canonical factorization over GF
      -- ([LN] p.122, Lemma 3.69).
      -- hence, if n = m * p^r where p is the characteristic of GF
      -- and gcd(m, p) = 1, we get
      -- Nq(n) = (1/n)* q^(n-m) * qPhi(X^m - 1)
      -- now X^m - 1 is the product of the (pairwise relatively prime)
      -- cyclotomic polynomials Qd(X) for which d divides m
      -- ([LN] p.64, Th. 2.45), and each Qd(X) factors into
      -- eulerPhi(d)/e (distinct) monic irreducible polynomials in GF[X]
      -- of the same degree e, where e is the least positive integer k
      -- such that d divides q^k - 1 ([LN] p.65, Th. 2.47)
      n = 1 => (sizeGF - 1) :: NNI :: PI
      m : PI := n
      p : PI := characteristic()$GF :: PI
      q : PI := sizeGF
      while (m rem p) = 0 repeat   -- find m such that
        m := (m quo p) :: PI       -- n = m * p^r and gcd(m, p) = 1
      m = 1 =>
         -- know that n is a power of p
        (((q ^ ((n-1)::NNI) )  * (q - 1) ) quo n) :: PI
      prod : I := q - 1
      divisorsOfm : L PI := rest(divisors m) pretend L PI
      for d in divisorsOfm repeat
        -- determine the multiplicative order of q modulo d
        e  : PI := 1
        qe : PI := q
        while (qe rem d) ~= 1 repeat
          e  := e + 1
          qe := qe * q
        prod := prod * _
          qcoerce((qe - 1) ^ (qcoerce(eulerPhi(d) quo e)) )
      qcoerce(q^(qcoerce(n - m)@NNI) * prod quo n)

    -- test if monic irreducible f is primitve
    primitive_i?(f : SUP) : Boolean ==
      -- let GF be a field of order q; a monic polynomial f in GF[X]
      -- of degree n is primitive over GF if and only if its constant
      -- term is non-zero, f is irreducible and,
      -- for each prime divisor d of q^n - 1,
      -- f does not divide X^((q^n - 1) / d) - 1
      -- (cf. [LN] p.89, Th. 3.16, and p.87, following Th. 3.11)
      n : NNI := degree f
      n = 0 => false
      q  : PI := sizeGF
      qn1 : PI := (q^n - 1) :: NNI :: PI
      setPoly f
      x := reduce(monomial(1, 1)$SUP)$MM -- X rem f represented in MM
      lrec  := factorList(factor qn1)
      lfact : L PI := []              -- collect the prime factors
      for rec in lrec repeat          -- of q^n - 1
        lfact := cons((rec.factor) :: PI, lfact)
      for d in lfact repeat
        if (expt := (qn1 quo d)) >= n then
          lift(x ^ expt)$MM = 1 => return false
      true

    primitive?(f) ==
        degree(f) = 0 => false
        leadingCoefficient f ~= 1 => false
        coefficient(f, 0) = 0 => false
        -- cheaper and prunes better than computation of x^(q^n - 1)
        not(irreducible?(f)) => false
        primitive_i?(f)

    normal? f ==
      -- let GF be a field with q elements; a monic irreducible
      -- polynomial f in GF[X] of degree n is normal if its roots
      -- x, x^q, ... , x^(q^(n-1)) are linearly independent over GF
      n : NNI := degree f
      n = 0 => false
      leadingCoefficient f ~= 1 => false
      coefficient(f, 0) = 0 => false
      n = 1 => true
      not irreducible? f => false
      g := reducedQPowers(f)
      l := [entries vectorise(g.i, n)$SUP for i in 0..(n-1)::NNI]
      rank(matrix(l)$Matrix(GF)) = n => true
      false

    normal_and_primitive?(f : SUP) : Boolean ==
        normal?(f) and primitive_i?(f)

    nextSubset(s, bound) ==
      m : NNI := #(s)
      m = 0 => [1]
      -- find the first element s(i) of s such that s(i) + 1 < s(i+1) :
      noGap : Boolean := true
      i : NNI := 0
      restOfs : L NNI
      while noGap and not empty?(restOfs := rest s) repeat
      -- after i steps (0 <= i <= m-1) we have s = [s(i), ... , s(m)]
      -- and restOfs = [s(i+1), ... , s(m)]
        secondOfs := first restOfs    -- s(i+1)
        firstOfsPlus1 := first s + 1  -- s(i) + 1
        secondOfs = firstOfsPlus1 =>
          s := restOfs
          i := i + 1
        setfirst!(s, firstOfsPlus1)  -- s := [s(i)+1, s(i+1), ..., s(m)]
        noGap := false
      if noGap then                   -- here s = [s(m)]
        firstOfs := first s
        firstOfs < bound => setfirst!(s, firstOfs + 1) -- s := [s(m)+1]
        m < bound =>
            setfirst!(s, m + 1)      -- s := [m+1]
            i := m
        return "failed"               -- (here m = s(m) = bound)
      for j in i..1 by -1 repeat  -- reconstruct the destroyed
        s := cons(j, s)           -- initial part of s
      s

    lexSmaller?(f : SUP, g : SUP) : Boolean ==
        n := degree(f)
        n ~= degree(g) => error "polynomials must have equal degrees"
        n < 1 => error "polynomials must have positive degree"
        k1 := numberOfMonomials(f)
        k2 := numberOfMonomials(g)
        k1 < k2 => true
        k2 < k1 => false
        f1 := reductum(f)
        g1 := reductum(g)
        while f1 ~= 0 repeat
            k1 := degree(f1)
            k2 := degree(g1)
            k1 < k2 => return true
            k2 < k1 => return false
            f1 := reductum(f1)
            g1 := reductum(g1)
        f1 := reductum(f)
        g1 := reductum(g)
        while f1 ~= 0 repeat
            k1 := lookup(leadingCoefficient(f1))
            k2 := lookup(leadingCoefficient(g1))
            k1 < k2 => return true
            k2 < k1 => return false
            f1 := reductum(f1)
            g1 := reductum(g1)
        false

    ll_cmp(x1 : GF, x2 : GF) : SingleInteger ==
        x1 = 0 and x2 ~= 0 => -1
        x1 ~= 0 and x2 = 0 => 1
        k1 := lookup(x1)
        k2 := lookup(x2)
        k1 < k2 => -1
        k2 < k2 => 1
        0

    clexSmaller?(f : SUP, g : SUP) : Boolean ==
        n := degree(f)
        n ~= degree(g) => error "polynomials must have equal degrees"
        n < 1 => error "polynomials must have positive degree"
        s := ll_cmp(coefficient(f, 0), coefficient(g, 0))
        s < 0 => true
        0 < s => false
        lexSmaller?(f, g)

    nlexSmaller?(f : SUP, g : SUP) : Boolean ==
        n := degree(f)
        n ~= degree(g) => error "polynomials must have equal degrees"
        n < 1 => error "polynomials must have positive degree"
        s := ll_cmp(coefficient(f, (n - 1)::NNI), coefficient(g, (n - 1)::NNI))
        s < 0 => true
        0 < s => false
        lexSmaller?(f, g)

    cnlexSmaller?(f : SUP, g : SUP) : Boolean ==
        n := degree(f)
        n ~= degree(g) => error "polynomials must have equal degrees"
        n < 1 => error "polynomials must have positive degree"
        s := ll_cmp(coefficient(f, 0), coefficient(g, 0))
        s < 0 => true
        0 < s => false
        nlexSmaller?(f, g)

    v_NNI ==> PrimitiveArray(NNI)
    v_GF ==> PrimitiveArray(GF)

    vecs_to_pol(exp_v : v_NNI,  coeff_v : v_GF, w : NNI) : SUP ==
        resl : Repr := []
        for i in 0..w repeat
            resl := cons([exp_v(i), coeff_v(i)], resl)
        rep_to_SUP(resl)

    do_weight(exp_v : v_NNI, ind_v : v_NNI, coeff_v : v_GF,
              min_i : NNI, max_i : NNI, w : NNI,
              tp? : SUP -> Boolean) : Union(SUP, "failed") ==
        -- skip reducible cases
        if sizeGF = 2 and odd?(w) then
            -- fill vectors with expected values
            for i in min_i..(max_i - 1) repeat
                exp_v(i) := i
                coeff_v(i) := elem1
                ind_v(i) := 1
            return "failed"
        repeat
            i := min_i
            while i < max_i repeat
                j := ind_v(i)
                j := j + 1 -- lookup(f_i)$GF + 1
                j = sizeGF =>
                    ind_v(i) := 1
                    coeff_v(i) := elem1
                    i := i + 1
                ind_v(i) := j
                coeff_v(i) := index(j::PI)
                break
            -- if coeffs wrapped around need to take next
            -- exponents tuple
            if i = max_i then
                i := max(min_i, 1)
                while i < max_i repeat
                    j := exp_v(i)
                    j := j + 1
                    j = exp_v(i + 1) =>
                        exp_v(i) := exp_v(i - 1) + 1
                        i := i + 1
                    exp_v(i) := j
                    break
                -- need bigger weight, fail this one
                i = max_i => return "failed"
            pol := vecs_to_pol(exp_v, coeff_v, w)
            -- print(pol::OutputForm)
            tp?(pol) => return pol

    -- run through the possible weights, starting from w
    do_weights(exp_v : v_NNI, ind_v : v_NNI, coeff_v : v_GF,
               min_i : NNI, max_i : NNI, w : NNI,
               tp? : SUP -> Boolean) : Union(SUP, "failed") ==
        n := exp_v(w)
        repeat
            -- skip weight if there nothing else to increase
            if max_i > min_i then
                resu := do_weight(exp_v, ind_v, coeff_v, min_i,
                                  max_i, w, tp?)
                resu case SUP => return resu::SUP
            w = n => return "failed"
            w1 := w
            w := w + 1
            i := w
            for i1 in w1..max_i by -1 repeat
                exp_v(i) := exp_v(i1)
                coeff_v(i) := coeff_v(i1)
                i := i1
            exp_v(max_i) := max_i
            ind_v(max_i) := 1
            coeff_v(max_i) := elem1
            max_i := max_i + 1
            -- artificial, we will bump it in do_weight
            ind_v(min_i) := 0

    get_rep(f) ==> f pretend Repr

    nextIrreduciblePoly f ==
        n : NNI := degree f
        n = 0 => error "polynomial must have positive degree"
        -- make f monic
        if (lcf := leadingCoefficient f) ~= 1 then f := (inv lcf) * f
        f_rep : Repr := get_rep(f)
        c0 := coefficient(f, 0)
        n = 1 =>
            xn := first(f_rep)
            lc : NNI := (c0 = 0 => 0; lookup(c0))
            lc = sizeGF - 1 => "failed"
            c := index((lc + 1)::PI)
            rep_to_SUP([xn, [0, c]$Rec])
        w : NNI := (#(f_rep) - 1) :: NNI
        if c0 = 0 then w := w + 1
        good_binomials := true
        -- skip binomials if all are reducible
        if n > 1 and w = 1 then
            facs := factors(factor(n))
            good_binomials : Boolean := odd?(char_GF)
            for fac in facs while good_binomials repeat
                fac.factor = 2 and fac.exponent > 1 =>
                    (sizeGF - 1) rem 4 ~= 0 =>
                        good_binomials := false
                if (sizeGF - 1) rem fac.factor ~= 0 then
                    good_binomials := false
            if not(good_binomials) then w := 2
        exp_v : v_NNI := new(n + 1, 0)
        ind_v : v_NNI := new(n + 1, 0)
        coeff_v : v_GF := new(n + 1, 0)
        for term in f_rep for i in 0.. repeat
            exp_v(w - i) := term.expnt
            ci := term.coeff
            coeff_v(w - i) := ci
            ind_v(w - i) := lookup(ci)
        if not(good_binomials) then
            exp_v(1) := 1
            coeff_v(1) := elem1
            ind_v(1) := 1
        do_weights(exp_v, ind_v, coeff_v, 0, w, w, irreducible?)

    lc_Rec ==> Record(nl : PI, nc : GF)

    -- Find nl bigger or equal than l such that m1_to_n*index(nl)
    -- is primitive.  If succesful return [nl, index(nl)],
    -- otherwise return "failed"
    get_next_GF_generator(l : NNI, m1_to_n : GF) : Union(lc_Rec, "failed") ==
        l1 := l::PI
        while l1 < sizeGF repeat
            c := index(l1)$GF
            primitive?(m1_to_n*c)$GF => return [l1, c]
            l1 := l1 + 1
        "failed"

    nextPrimitivePoly f ==
        n : NNI := degree f
        n = 0 => error "polynomial must have positive degree"
        -- make f monic
        if (lcf := leadingCoefficient f) ~= 1 then f := (inv lcf) * f
        f_rep : Repr := get_rep(f)
        xn : Rec := first(f_rep)
        c0 : GF  := coefficient(f, 0)
        lc : NNI := lookup(c0)$GF
        n = 1 =>
             m1_to_n := -(1$GF)
             -- x + c is primitive iff -c is primitve
             lcu := get_next_GF_generator(lc + 1, m1_to_n)
             lcu case "failed" => "failed"
             c := (lcu::lc_Rec).nc
             rep_to_SUP([xn, [0, c]$Rec])
        w : NNI := (#(f_rep) - 1)::NNI
        if c0 = 0 then w := w + 1
        exp_v : v_NNI := new(n + 1, 0)
        ind_v : v_NNI := new(n + 1, 0)
        coeff_v : v_GF := new(n + 1, 0)
        for term in f_rep for i in 0.. repeat
            exp_v(w - i) := term.expnt
            ci := term.coeff
            coeff_v(w - i) := ci
            ind_v(w - i) := lookup(ci)
        -- a necessary condition for a monic polynomial f of degree n
        -- over GF to be primitive is that (-1)^n * f(0) be a
        -- primitive element of GF (cf. [LN] p.90, Th. 3.18)
        c  : GF  := c0
        m1_to_n := ((-1$Integer)^n)::GF
        -- if c = 0 then set lc to 1
        if c = 0 then lc := 1
        repeat
            lcu := get_next_GF_generator(lc, m1_to_n)
            lcu case "failed" => return "failed"
            lcr := lcu::lc_Rec
            -- move to next constant term
            lc := lcr.nl + 1
            ind_v(0) := lcr.nl
            coeff_v(0) := c := lcr.nc
            if not(c = c0 and w > 1) then
                -- X^n + c can not be primitive for n > 1 (cf. [LN] p.90,
                -- Th. 3.18); next possible polynomial is X^n + X + c
                w := 2
                exp_v(1) := 1
                ind_v(1) := 0
                coeff_v(1) := 0
                exp_v(w) := n
                ind_v(w) := 1
                coeff_v(w) := 1
            resu := do_weights(exp_v, ind_v, coeff_v, 1, w, w, primitive?)
            resu case SUP => return resu::SUP

    nextNormalPoly f ==
        n : NNI := degree f
        n = 0 => error "polynomial must have positive degree"
        n1 := (n - 1)::NNI
        -- make f monic
        if (lcf := leadingCoefficient(f)) ~= 1 then f := (inv lcf) * f
        f_rep : Repr := get_rep(f)
        a0 : GF  := coefficient(f, n1)
        la  : NNI := lookup(a0)$GF rem sizeGF
        n = 1 =>
            xn : Rec  := first(f_rep)
            -- the polynomial X + a is normal if and only if a is not zero
            la = sizeGF - 1 => "failed"
            rep_to_SUP([xn, [0, index((la + 1)::PI)$GF]$Rec])

        -- if the polynomial X^n + a * X^(n-1) + ... is normal then
        -- a = -(x + x^q +...+ x^(q^n)) can not be zero (where q = #GF)
        a  : GF  := a0
        -- if a = 0 then set la := 1
        if la = 0 then
            la := 1
            a := elem1
        w : NNI := (#(f_rep) - 1) :: NNI
        if coefficient(f, 0) = 0 then w := w + 1
        exp_v : v_NNI := new(n + 1, 0)
        ind_v : v_NNI := new(n + 1, 0)
        coeff_v : v_GF := new(n + 1, 0)
        for term in f_rep for i in 0.. repeat
            exp_v(w - i) := term.expnt
            ci := term.coeff
            coeff_v(w - i) := ci
            ind_v(w - i) := lookup(ci)
        while la < sizeGF repeat
            -- (run through the possible values of a)
            if not(a = a0) then
                w := 2
                ind_v(0) := 0
                coeff_v(0) := 0
                exp_v(w - 1) := n1
                ind_v(w - 1) := la
                coeff_v(w - 1) := a
                exp_v(w) := n
                ind_v(w) := 1
                coeff_v(w) := 1
            resu := do_weights(exp_v, ind_v, coeff_v, 0, (w - 1)::NNI,
                               w, normal?)
            resu case SUP => return resu::SUP
            la := la + 1
            a := index(la::PI)$GF
        "failed"

    nextNormalPrimitivePoly f ==
        n : NNI := degree f
        -- degree 1 primitive polynomial is normal
        n = 1 => nextPrimitivePoly(f)
        n = 0 => error "polynomial must have positive degree"
        n1 := (n - 1)::NNI
        -- make f monic
        if (lcf := leadingCoefficient f) ~= 1 then f := (inv lcf) * f
        f_rep : Repr := get_rep(f)
        c0 : GF  := coefficient(f, 0)
        lc : NNI := lookup(c0)$GF
        a0 : GF  := coefficient(f, n1)
        la : NNI := lookup(a0)$GF
        -- if the polynomial X^n + a * X^(n-1) +...+ c is primitive and
        -- normal over GF then (-1)^n * c is a primitive element of GF
        -- (cf. [LN] p.90, Th. 3.18), and a = -(x + x^q +...+ x^(q^n))
        -- is not zero (where q = #GF)
        c : GF  := c0
        a : GF  := a0
        -- if a = 0 then set la := 1
        if a = 0 then
            la := 1
            a  := elem1
        m1_to_n := ((-1$Integer)^n)::GF
        w : NNI := (#(f_rep) - 1) :: NNI
        -- if c = 0 then set lc to 1
        if c = 0 then
            lc := 1
            w := w + 1
        exp_v : v_NNI := new(n + 1, 0)
        ind_v : v_NNI := new(n + 1, 0)
        coeff_v : v_GF := new(n + 1, 0)
        for term in f_rep for i in 0.. repeat
            exp_v(w - i) := term.expnt
            ci := term.coeff
            coeff_v(w - i) := ci
            ind_v(w - i) := lookup(ci)
        first_pass := true
        repeat
            lcu := get_next_GF_generator(lc, m1_to_n)
            lcu case "failed" => return "failed"
            lcr := lcu::lc_Rec
            lc := lcr.nl
            c := lcr.nc
            while la < sizeGF repeat
                -- We use original coefficients only on first
                -- pass here and then only when a0 and c0 were OK.
                -- Otherwise we need to reinitialize vectors
                if not (a = a0 and c = c0) then
                    first_pass := false
                    w := 2
                    ind_v(0) := lc
                    coeff_v(0) := c
                    exp_v(w - 1) := n1
                    ind_v(w - 1) := la
                    coeff_v(w - 1) := a
                    exp_v(w) := n
                    ind_v(w) := 1
                    coeff_v(w) := 1
                if w = 2 and not(first_pass) then
                    pol := vecs_to_pol(exp_v, coeff_v, w)
                    normal_and_primitive?(pol) => return pol
                resu := do_weights(exp_v, ind_v, coeff_v, 1,
                                   (w - 1)::NNI, w, normal_and_primitive?)
                resu case SUP => return resu::SUP
                la := la + 1
                a  := index(la :: PI)$GF
            la := 1
            a := 1
            lc := lc + 1

    nextPrimitiveNormalPoly f == nextNormalPrimitivePoly f

    createIrreduciblePoly n ==
        x := monomial(1, 1)$SUP
        n = 1 => x
        xn := monomial(1, n)$SUP
        -- does not make much sense, but we do this to keep output
        -- the same as in earlier versions
        n >= sizeGF => nextIrreduciblePoly(xn + x) :: SUP

        dg := get_deg_GF()
        kg : GF :=
            poly_or_prime_rep =>
                (l := gcd(n, dg)) > 1 =>
                    index((char_GF^((dg exquo l)::NNI) - 1)::PI)
                odd? n => 1
                0
            0
        nextIrreduciblePoly(xn + kg::SUP)::SUP

    createPrimitivePoly n ==
    -- (see also the comments in the code of nextPrimitivePoly)
      xn := monomial(1, n)$SUP
      n = 1 => xn + monomial(-primitiveElement()$GF, 0)$SUP
      c0 : GF := (-1)^n * primitiveElement()$GF
      constterm : Rec := [0, c0]$Rec
      -- try first (probably faster) the polynomials
      -- f = X^n + f{n-1}*X^(n-1) +...+ f1*X + c0 for which
      -- fi is 0 or 1 for i=1, ..., n-1,
      -- and this in the order used to define nextPrimitivePoly
      s  : L NNI := [0, 1]
      weight : NNI := 2
      s1 : L NNI := [1]
      n1 : NNI := (n - 1) :: NNI
      notReady : Boolean := true
      while notReady repeat
        polRepr : Repr := [constterm]
        while not empty? s1 repeat
          polRepr := cons([first s1, 1]$Rec, polRepr)
          s1 := rest s1
        polRepr := cons([n, 1]$Rec, polRepr)
        --
        -- may be improved by excluding reciprocal polynomials
        --
        primitive? (pol := listToSUP polRepr) => return pol
        if weight = n then notReady := false
        else
          s1 := nextSubset(rest s, n1) :: L NNI
          s  := cons(0, s1)
          weight := #s
      -- if there is no primitive f of the above form
      -- search now from the beginning, allowing arbitrary
      -- coefficients f_i, i = 1, ..., n-1
      nextPrimitivePoly(xn + monomial(c0, 0)$SUP) :: SUP

    createNormalPoly n  ==
      n = 1 => monomial(1, 1)$SUP + monomial(-1, 0)$SUP
      -- get a normal polynomial f = X^n + a * X^(n-1) + ...
      -- with a = -1
      -- [recall that if f is normal over the field GF of order q
      -- then a = -(x + x^q +...+ x^(q^n)) can not be zero;
      -- hence the existence of such an f follows from the
      -- normal basis theorem ([LN] p.60, Th. 2.35) and the
      -- surjectivity of the trace ([LN] p.55, Th. 2.23 (iii))]
      nextNormalPoly(monomial(1, n)$SUP
                       + monomial(-1, (n-1) :: NNI)$SUP) :: SUP

    createNormalPrimitivePoly n ==
      xn := monomial(1, n)$SUP
      n = 1 => xn + monomial(-primitiveElement()$GF, 0)$SUP
      n1  : NNI := (n - 1) :: NNI
      c0  : GF  := (-1)^n * primitiveElement()$GF
      constterm  := monomial(c0, 0)$SUP
      -- try first the polynomials f = X^n + a *  X^(n-1) + ...
      -- with a = -1 (there should be one)
      pol := xn + monomial(-1, n1)$SUP + constterm
      normal? pol and primitive? pol => pol
      res := nextNormalPrimitivePoly(pol)
      res case SUP => res
      print(message("weird, can not find normal and primitve"
                    "poly with a{n-1} = -1")$OutputForm)
      -- if there is no normal primitive f with a = -1
      -- get now one with arbitrary (non-zero) a
      -- (the existence is proved in [LS])
      -- FIXME: elem1 instead of 1 ????
      pol := xn + monomial(1, n1)$SUP + constterm
      normal? pol and primitive? pol => pol
      nextNormalPrimitivePoly(pol) :: SUP

    createPrimitiveNormalPoly n == createNormalPrimitivePoly n

--    qAdicExpansion m ==
--      ragits : List I := wholeRagits(m :: (RadixExpansion sizeGF))
--      pol  : SUP := 0
--      expt : NNI := #ragits
--      for i in ragits repeat
--        expt := (expt - 1) :: NNI
--        if i ~= 0 then pol := pol + monomial(index(i::PI)$GF, expt)
--      pol

--    random == qAdicExpansion(random()$I)

--    random n ==
--      pol := monomial(1, n)$SUP
--      n1 : NNI := (n - 1) :: NNI
--      for i in 0..n1 repeat
--        if (c := random()$GF) ~= 0 then
--          pol := pol + monomial(c, i)$SUP
--      pol

    random n ==
      polRepr : Repr := []
      n1 : NNI := (n - 1) :: NNI
      for i in 0..n1 repeat
        if (c := random()$GF) ~= 0 then
          polRepr := cons([i, c]$Rec, polRepr)
      rep_to_SUP(cons([n, 1$GF]$Rec, polRepr))

    random(m, n) ==
      if m > n then (m, n) := (n, m)
      d : NNI := (n - m) :: NNI
      if d > 1 then n := (random(d)$I + m) :: PI
      random(n)


)abbrev package FFPOLY2 FiniteFieldPolynomialPackage2
++ Authors: J.Grabmeier, A.Scheerhorn
++ Date Created: 26.03.1991
++ Basic Operations: rootOfIrreduciblePoly
++ Related Constructors: FiniteFieldCategory
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, zeros of polynomials, Berlekamp's trace algorithm
++ References:
++  R.Lidl, H.Niederreiter: Finite Field, Encyclopedia of Mathematics and
++  Its Applications, Vol. 20, Cambridge Univ. Press, 1983, ISBN 0 521 30240 4
++  J. Grabmeier, A. Scheerhorn: Finite Fields in Axiom.
++   Axiom Technical Report Series, ATR/5 NP2522.
++ Description:
++  FiniteFieldPolynomialPackage2(F, GF) exports some functions concerning
++  finite fields, which depend on a finite field {\em GF} and an
++  algebraic extension F of {\em GF}, e.g. a zero of a polynomial
++  over {\em GF} in F.
FiniteFieldPolynomialPackage2(F, GF) : Exports == Implementation where
  F : FieldOfPrimeCharacteristic with
      coerce : GF -> %
        ++ coerce(x) \undocumented{}
      lookup : % -> PositiveInteger
        ++ lookup(x) \undocumented{}
      basis : PositiveInteger -> Vector %
        ++ basis(n) \undocumented{}
      Frobenius : % -> %
        ++ Frobenius(x) \undocumented{}
  -- F should be a algebraic extension of the finite field GF, either an
  -- algebraic closure of GF or a simple algebraic extension field of GF
  GF : FiniteFieldCategory

  I   ==> Integer
  NNI ==> NonNegativeInteger
  PI  ==> PositiveInteger
  SUP ==> SparseUnivariatePolynomial
  MM  ==> ModMonic(GF, SUP GF)
  OUT ==> OutputForm
  M   ==> Matrix
  V   ==> Vector
  L   ==> List
  FFPOLY ==> FiniteFieldPolynomialPackage(GF)
  SUPF2 ==> SparseUnivariatePolynomialFunctions2(GF, F)

  Exports ==> with

    rootOfIrreduciblePoly : SUP GF -> F
      ++ rootOfIrreduciblePoly(f) computes one root of the monic,
      ++ irreducible polynomial f, which degree must divide the extension degree
      ++ of {\em F} over {\em GF},
      ++ i.e. f splits into linear factors over {\em F}.


  Implementation ==> add

-- we use berlekamps trace algorithm
-- it is not checked whether the polynomial is irreducible over GF]]
    rootOfIrreduciblePoly(pf) ==
--    not irreducible(pf)$FFPOLY =>
--      error("polynomial has to be irreducible")
      sizeGF := size()$GF
      -- if the polynomial is of degree one, we're ready
      deg := degree(pf)$(SUP GF)::PI
      deg = 0 => error("no roots")
      deg = 1 => -coefficient(pf, 0)$(SUP GF)::F
      p : SUP F := map(coerce, pf)$SUPF2
      -- compute qexp, qexp(i) = x ^(size()GF ^ i) mod p
      -- with this list it's easier to compute the gcd(p(x), trace(x))
      qexp := reducedQPowers(pf)$FFPOLY
      stillToFactor := p
      -- take linear independent elements, the basis of F over GF
      basis : Vector F := basis(deg)$F
      basispointer : I := 1
      -- as p is irreducible over GF, 0 can't be a root of p
      -- therefore we can use the predicate zero?(root) for indicating
      -- whether a root is found
      root := 0$F
      while zero?(root)$F repeat
        beta : F := basis.basispointer
        -- gcd(trace(x)+gf, p(x)) has degree 0, that's why we skip beta=1
        if beta = 1$F then
          basispointer := basispointer + 1
          beta := basis.basispointer
        basispointer := basispointer+1
        -- compute the polynomial trace(beta * x) mod p(x) using explist
        trModp : SUP F := map(coerce, qexp.0)$SUPF2 * beta
        for i in 1..deg-1 repeat
          beta := Frobenius(beta)
          trModp := trModp +$(SUP F) beta *$(SUP F) map(coerce, qexp.i)$SUPF2
        -- if it is of degree 0, it doesn't help us finding a root
        if degree(trModp)$(SUP F) > 0 then
          -- for all elements gf of GF do
          for j in 1..sizeGF repeat
            -- compute gcd(trace(beta * x) + gf, stillToFactor)
            h := gcd(stillToFactor, trModp +$(SUP F) _
             (index(qcoerce(j))$GF::F::(SUP F)))$(SUP F)
            -- make the gcd polynomial monic
            if leadingCoefficient(h)$(SUP F) ~= 1$F then
              h := (inv leadingCoefficient(h)) * h
            degh := degree(h)$(SUP F)
            degSTF := degree(stillToFactor)$(SUP F)
            -- if the gcd has degree one we are ready
            degh = 1 => root := -coefficient(h, 0)$(SUP F)
            -- if the quotient of stillToFactor and the gcd has
            -- degree one, we're also ready
            degSTF - degh = 1 =>
              root := -coefficient(stillToFactor quo h, 0)$(SUP F)
            -- otherwise the gcd helps us finding a root, only if its
            -- degree is between 2 and degree(stillToFactor)-2
            if degh > 1 and degh < degSTF then
              2*degh > degSTF => stillToFactor := stillToFactor quo h
              stillToFactor := h
      root

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
